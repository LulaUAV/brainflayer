#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "sha256.h"

/* byte conversion */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
# define be32(x) __builtin_bswap32(x)
# define be64(x) __builtin_bswap64(x)
#else
# define be32(x) (x)
# define be64(x) (x)
#endif

#include "ripemd160.c"

static void sha256_transform_internal(uint32_t *digest, const char *data, uint64_t nblk);

extern void sha256_transform_ssse3(uint32_t *digest, const char *data, uint64_t nblk);
extern void sha256_transform_avx(uint32_t *digest, const char *data, uint64_t nblk);
extern void sha256_transform_rorx(uint32_t *digest, const char *data, uint64_t nblk);
extern void sha256_ni_transform(uint32_t *digest, const char *data, uint64_t nblk);

extern int sha256_ssse3_built();
extern int sha256_avx_built();
extern int sha256_rorx_built();
extern int sha256_ni_built();

static void (*sha256_transform_func)(uint32_t *digest, const char *data, uint64_t nblk)=
  sha256_transform_internal;

/* static padding for 256 bit input */
static uint8_t rmd160_256[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x80, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,
  /* length 256 bits, little endian uint64_t */
  0x00, 0x01, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00
};

void Hash160(uint8_t hash[], const uint8_t data[], size_t len) {
  SHA2_256(rmd160_256, data, len);
  ripemd160_rawcompress(rmd160_256, hash);
}

// caller is responsible for padding
inline void Hash160_Raw(uint8_t hash[], const uint8_t data[], uint64_t nblk) {
  uint32_t *rmd160_in = (uint32_t *)rmd160_256;
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  sha256_transform_func(state, data, nblk);

  rmd160_in[0] = be32(state[0]); rmd160_in[1] = be32(state[1]);
  rmd160_in[2] = be32(state[2]); rmd160_in[3] = be32(state[3]);
  rmd160_in[4] = be32(state[4]); rmd160_in[5] = be32(state[5]);
  rmd160_in[6] = be32(state[6]); rmd160_in[7] = be32(state[7]);

  ripemd160_rawcompress(rmd160_256, hash);
}

static uint8_t input25[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 200 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0xc8
};
void Hash160_25(uint8_t hash[], const uint8_t data[]) {
  memcpy(input25, data, 25);
  Hash160_Raw(hash, input25, 1);
}

static uint8_t input33[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 264 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x08
};
void Hash160_33(uint8_t hash[], const uint8_t data[]) {
  memcpy(input33, data, 33);
  Hash160_Raw(hash, input33, 1);
}

static uint8_t input35[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 280 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x18
};
void Hash160_35(uint8_t hash[], const uint8_t data[]) {
  memcpy(input35, data, 35);
  Hash160_Raw(hash, input35, 1);
}

static uint8_t input37[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 296 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x28
};
void Hash160_37(uint8_t hash[], const uint8_t data[]) {
  memcpy(input37, data, 37);
  Hash160_Raw(hash, input37, 1);
}

static uint8_t input65[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 520 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x08
};
void Hash160_65(uint8_t hash[], const uint8_t data[]) {
  memcpy(input65, data, 65);
  Hash160_Raw(hash, input65, 2);
}

static uint8_t input67[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 536 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x18
};
void Hash160_67(uint8_t hash[], const uint8_t data[]) {
  memcpy(input67, data, 67);
  Hash160_Raw(hash, input67, 2);
}

static uint8_t input69[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 552 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x28
};
void Hash160_69(uint8_t hash[], const uint8_t data[]) {
  memcpy(input69, data, 69);
  Hash160_Raw(hash, input69, 2);
}

inline void SHA2_256(uint8_t hash[], const uint8_t data[], size_t len) {
  static uint8_t padding[128];
  uint64_t dblk = len >> 6; // divide by 64, rounding down
  int remaining_bytes = len & 63;

  // initialize state
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  // copy partial block bytes into the padding
  memcpy(padding, data + (dblk << 6), remaining_bytes);
  // set a 1 bit after the data
  padding[remaining_bytes] = 0x80;

  sha256_transform_func(state, data, dblk);
  // set length
  if (remaining_bytes < 56) {
    memset(padding + remaining_bytes + 1, 0,  56 - (remaining_bytes + 1));
    ((uint64_t *)padding)[ 7] = be64(len * 8);
    sha256_transform_func(state, padding, 1);
  } else {
    memset(padding + remaining_bytes + 1, 0, 120 - (remaining_bytes + 1));
    ((uint64_t *)padding)[15] = be64(len * 8);
    sha256_transform_func(state, padding, 2);
  }

  // write out result
  ((uint32_t *)hash)[0] = be32(state[0]);
  ((uint32_t *)hash)[1] = be32(state[1]);
  ((uint32_t *)hash)[2] = be32(state[2]);
  ((uint32_t *)hash)[3] = be32(state[3]);
  ((uint32_t *)hash)[4] = be32(state[4]);
  ((uint32_t *)hash)[5] = be32(state[5]);
  ((uint32_t *)hash)[6] = be32(state[6]);
  ((uint32_t *)hash)[7] = be32(state[7]);
}

void SHA2_256_Init(SHA2_256_CTX *ctx) {
  ctx->bitlen = 0;
  ctx->datalen = 0;
  ctx->state[0] = 0x6a09e667;
  ctx->state[1] = 0xbb67ae85;
  ctx->state[2] = 0x3c6ef372;
  ctx->state[3] = 0xa54ff53a;
  ctx->state[4] = 0x510e527f;
  ctx->state[5] = 0x9b05688c;
  ctx->state[6] = 0x1f83d9ab;
  ctx->state[7] = 0x5be0cd19;
}

void SHA2_256_Update(SHA2_256_CTX *ctx, const uint8_t data[], size_t len) {
  size_t i = 0;

  uint8_t *input = (uint8_t *)data;

  if (ctx->datalen > 0) {
    i = 64 - ctx->datalen;
    if (i > len) {
      memcpy(ctx->data + ctx->datalen, input, len);
      ctx->datalen += len;
      return;
    } else {
      memcpy(ctx->data + ctx->datalen, input, i);
      sha256_transform_func(ctx->state, ctx->data, 1);
      ctx->bitlen += 512;
      ctx->datalen = 0;
      input += i;
      len -= i;
    }
  }

  if (len >= 64) {
    i = len / 64;
    sha256_transform_func(ctx->state, input, i);
    len -= i * 64;
    input += i * 64;
    ctx->bitlen += i * 512;
  }

  memcpy(ctx->data, input, len);
  ctx->datalen = len;
}

void SHA2_256_Final(uint8_t hash[], SHA2_256_CTX *ctx) {
  uint32_t i = ctx->datalen;

  if (ctx->datalen < 56) {
    ctx->data[i++] = 0x80;
    memset(ctx->data + i, 0, 56 - i);
  } else {
    ctx->data[i++] = 0x80;
    memset(ctx->data + i, 0, 64 - i);
    sha256_transform_func(ctx->state, ctx->data, 1);
    memset(ctx->data, 0, 56);
  }

  // padding
  ctx->bitlen += ctx->datalen * 8;
  ((uint64_t *)ctx->data)[7] = be64(ctx->bitlen);

  sha256_transform_func(ctx->state, ctx->data, 1);

  ((uint32_t *)hash)[0] = be32(ctx->state[0]);
  ((uint32_t *)hash)[1] = be32(ctx->state[1]);
  ((uint32_t *)hash)[2] = be32(ctx->state[2]);
  ((uint32_t *)hash)[3] = be32(ctx->state[3]);
  ((uint32_t *)hash)[4] = be32(ctx->state[4]);
  ((uint32_t *)hash)[5] = be32(ctx->state[5]);
  ((uint32_t *)hash)[6] = be32(ctx->state[6]);
  ((uint32_t *)hash)[7] = be32(ctx->state[7]);
}

// caller responsible for making sure the buffer is big enough
uint64_t SHA2_256_Pad(uint8_t data[], size_t len) {
  uint64_t *bitlen_ptr;
  uint64_t nblk = len >> 6; // divide by 64, rounding down
  int remaining_bytes = len & 63;

  data[len] = 0x80;

  if (remaining_bytes < 56) {
    memset(data + len + 1, 0,  56 - (remaining_bytes + 1));
    nblk += 1;
  } else {
    memset(data + len + 1, 0, 120 - (remaining_bytes + 1));
    nblk += 2;
  }

  bitlen_ptr = (uint64_t *)(data + (nblk << 6) - 8);
  *bitlen_ptr = be64(len * 8);

  return nblk;
}

// caller is responsible for padding
void SHA2_256_Raw(uint8_t hash[], const uint8_t data[], uint64_t nblk) {
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  sha256_transform_func(state, data, nblk);

  ((uint32_t *)hash)[0] = be32(state[0]);
  ((uint32_t *)hash)[1] = be32(state[1]);
  ((uint32_t *)hash)[2] = be32(state[2]);
  ((uint32_t *)hash)[3] = be32(state[3]);
  ((uint32_t *)hash)[4] = be32(state[4]);
  ((uint32_t *)hash)[5] = be32(state[5]);
  ((uint32_t *)hash)[6] = be32(state[6]);
  ((uint32_t *)hash)[7] = be32(state[7]);
}

#include "sha256_xform.c"
#include "sha256_reg.c"
