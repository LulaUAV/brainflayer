#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include <endian.h>

#include "sha256.h"

#include "ripemd160_small.c"
#include "ripemd160_fast.c"
#include "ripemd160_asm.c"

static void sha256_xform_internal(uint32_t *digest, const char *data, uint32_t nblk);

extern void sha256_xform_nayuki64(uint32_t *digest, const char *data, uint32_t nblk);
extern void sha256_xform_ssse3(uint32_t *digest, const char *data, uint32_t nblk);
extern void sha256_xform_avx(uint32_t *digest, const char *data, uint32_t nblk);
extern void sha256_xform_rorx(uint32_t *digest, const char *data, uint32_t nblk);
extern void sha256_xform_ni(uint32_t *digest, const char *data, uint32_t nblk);

extern int sha256_nayuki64_built();
extern int sha256_ssse3_built();
extern int sha256_avx_built();
extern int sha256_rorx_built();
extern int sha256_ni_built();

#define RIPEMD160_COMPRESS(S, D) ripemd160_xform_func(S, D)

static void sha256_xform_default(uint32_t *a, const char *b, uint32_t c) {
  SHA2_256_Register(-1);
  SHA2_256_Transform(a, b, c);
}

void (*SHA2_256_Transform)(uint32_t *digest, const char *data, uint32_t nblk)=
  sha256_xform_default;

static void ripemd160_xform_default(uint32_t *digest, const char *data) {
  ripemd160_xform_func = ripemd160_fast;
  ripemd160_xform_func(digest, data);
}

void (*ripemd160_xform_func)(uint32_t *digest, const char *data)=
  ripemd160_xform_default;

/* static padding for 256 bit input */
static uint8_t rmd160_256[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x80, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 256 bits, little endian uint64_t */
  0x00, 0x01, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
};

static uint8_t sha256_256[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x80, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 256 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x00
};

void Hash256(uint8_t hash[], const uint8_t data[], size_t len) {
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  SHA2_256(sha256_256, data, len);
  SHA2_256_Transform(state, sha256_256, 1);

  ((uint32_t *)hash)[0] = htobe32(state[0]);
  ((uint32_t *)hash)[1] = htobe32(state[1]);
  ((uint32_t *)hash)[2] = htobe32(state[2]);
  ((uint32_t *)hash)[3] = htobe32(state[3]);
  ((uint32_t *)hash)[4] = htobe32(state[4]);
  ((uint32_t *)hash)[5] = htobe32(state[5]);
  ((uint32_t *)hash)[6] = htobe32(state[6]);
  ((uint32_t *)hash)[7] = htobe32(state[7]);
}

// caller is responsible for padding
void Hash256_Raw(uint8_t hash[], const uint8_t data[], uint64_t nblk) {
  uint32_t *sha256_in = (uint32_t *)sha256_256;
  uint32_t state1[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };
  uint32_t state2[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  SHA2_256_Transform(state1, data, nblk);

  sha256_in[0] = htobe32(state1[0]); sha256_in[1] = htobe32(state1[1]);
  sha256_in[2] = htobe32(state1[2]); sha256_in[3] = htobe32(state1[3]);
  sha256_in[4] = htobe32(state1[4]); sha256_in[5] = htobe32(state1[5]);
  sha256_in[6] = htobe32(state1[6]); sha256_in[7] = htobe32(state1[7]);

  SHA2_256_Transform(state2, sha256_256, 1);

  ((uint32_t *)hash)[0] = htobe32(state2[0]);
  ((uint32_t *)hash)[1] = htobe32(state2[1]);
  ((uint32_t *)hash)[2] = htobe32(state2[2]);
  ((uint32_t *)hash)[3] = htobe32(state2[3]);
  ((uint32_t *)hash)[4] = htobe32(state2[4]);
  ((uint32_t *)hash)[5] = htobe32(state2[5]);
  ((uint32_t *)hash)[6] = htobe32(state2[6]);
  ((uint32_t *)hash)[7] = htobe32(state2[7]);
}

void Hash160(uint8_t hash[], const uint8_t data[], size_t len) {
  SHA2_256(rmd160_256, data, len);
  RIPEMD160_COMPRESS((uint32_t *)hash, rmd160_256);
}

// caller is responsible for padding
inline void Hash160_Raw(uint8_t hash[], const uint8_t data[], uint64_t nblk) {
  uint32_t *rmd160_in = (uint32_t *)rmd160_256;
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  SHA2_256_Transform(state, data, nblk);

  rmd160_in[0] = htobe32(state[0]); rmd160_in[1] = htobe32(state[1]);
  rmd160_in[2] = htobe32(state[2]); rmd160_in[3] = htobe32(state[3]);
  rmd160_in[4] = htobe32(state[4]); rmd160_in[5] = htobe32(state[5]);
  rmd160_in[6] = htobe32(state[6]); rmd160_in[7] = htobe32(state[7]);

  RIPEMD160_COMPRESS((uint32_t *)hash, rmd160_256);
}

static uint8_t input22[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 176 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0xb0
};
void Hash160_22(uint8_t hash[], const uint8_t data[]) {
  memcpy(input22, data, 22);
  Hash160_Raw(hash, input22, 1);
}

static uint8_t input25[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 200 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0xc8
};
void Hash160_25(uint8_t hash[], const uint8_t data[]) {
  memcpy(input25, data, 25);
  Hash160_Raw(hash, input25, 1);
}

static uint8_t input33[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 264 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x08
};
void Hash160_33(uint8_t hash[], const uint8_t data[]) {
  memcpy(input33, data, 33);
  Hash160_Raw(hash, input33, 1);
}

static uint8_t input35[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 280 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x18
};
void Hash160_35(uint8_t hash[], const uint8_t data[]) {
  memcpy(input35, data, 35);
  Hash160_Raw(hash, input35, 1);
}

static uint8_t input37[64] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 296 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x01, 0x28
};
void Hash160_37(uint8_t hash[], const uint8_t data[]) {
  memcpy(input37, data, 37);
  Hash160_Raw(hash, input37, 1);
}

static uint8_t input65[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 520 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x08
};
void Hash160_65(uint8_t hash[], const uint8_t data[]) {
  memcpy(input65, data, 65);
  Hash160_Raw(hash, input65, 2);
}

static uint8_t input67[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 536 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x18
};
void Hash160_67(uint8_t hash[], const uint8_t data[]) {
  memcpy(input67, data, 67);
  Hash160_Raw(hash, input67, 2);
}

static uint8_t input69[128] = {
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
  /* length 552 bits, big endian uint64_t */
  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x02, 0x28
};
void Hash160_69(uint8_t hash[], const uint8_t data[]) {
  memcpy(input69, data, 69);
  Hash160_Raw(hash, input69, 2);
}

inline void SHA2_256(uint8_t hash[], const uint8_t data[], size_t len) {
  static uint8_t padding[128];
  uint64_t dblk = len >> 6; // divide by 64, rounding down
  int remaining_bytes = len & 63;

  // initialize state
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  // copy partial block bytes into the padding
  memcpy(padding, data + (dblk << 6), remaining_bytes);
  // set a 1 bit after the data
  padding[remaining_bytes] = 0x80;

  SHA2_256_Transform(state, data, dblk);
  // set length
  if (remaining_bytes < 56) {
    memset(padding + remaining_bytes + 1, 0,  56 - (remaining_bytes + 1));
    ((uint64_t *)padding)[ 7] = htobe64(len * 8);
    SHA2_256_Transform(state, padding, 1);
  } else {
    memset(padding + remaining_bytes + 1, 0, 120 - (remaining_bytes + 1));
    ((uint64_t *)padding)[15] = htobe64(len * 8);
    SHA2_256_Transform(state, padding, 2);
  }

  // write out result
  ((uint32_t *)hash)[0] = htobe32(state[0]);
  ((uint32_t *)hash)[1] = htobe32(state[1]);
  ((uint32_t *)hash)[2] = htobe32(state[2]);
  ((uint32_t *)hash)[3] = htobe32(state[3]);
  ((uint32_t *)hash)[4] = htobe32(state[4]);
  ((uint32_t *)hash)[5] = htobe32(state[5]);
  ((uint32_t *)hash)[6] = htobe32(state[6]);
  ((uint32_t *)hash)[7] = htobe32(state[7]);
}

void SHA2_256_Clone(SHA2_256_CTX *dst, const SHA2_256_CTX *src) {
  // relies on .data being first
  if (src->datalen) {
    memcpy(dst, src, sizeof(*dst));
  } else {
    memcpy(dst + sizeof(dst->data), src + sizeof(dst->data), sizeof(*dst) - sizeof(dst->data));
  }
}

void SHA2_256_Init(SHA2_256_CTX *ctx) {
  ctx->bitlen = 0;
  ctx->datalen = 0;
  ctx->state[0] = 0x6a09e667;
  ctx->state[1] = 0xbb67ae85;
  ctx->state[2] = 0x3c6ef372;
  ctx->state[3] = 0xa54ff53a;
  ctx->state[4] = 0x510e527f;
  ctx->state[5] = 0x9b05688c;
  ctx->state[6] = 0x1f83d9ab;
  ctx->state[7] = 0x5be0cd19;
}

void SHA2_256_Update(SHA2_256_CTX *ctx, const uint8_t data[], size_t len) {
  size_t i = 0;

  uint8_t *input = (uint8_t *)data;

  if (ctx->datalen > 0) {
    i = 64 - ctx->datalen;
    if (i > len) {
      memcpy(ctx->data + ctx->datalen, input, len);
      ctx->datalen += len;
      return;
    } else {
      memcpy(ctx->data + ctx->datalen, input, i);
      SHA2_256_Transform(ctx->state, ctx->data, 1);
      ctx->bitlen += 512;
      ctx->datalen = 0;
      input += i;
      len -= i;
    }
  }

  if (len >= 64) {
    i = len / 64;
    SHA2_256_Transform(ctx->state, input, i);
    len -= i * 64;
    input += i * 64;
    ctx->bitlen += i * 512;
  }

  memcpy(ctx->data, input, len);
  ctx->datalen = len;
}

void SHA2_256_Final(uint8_t hash[], SHA2_256_CTX *ctx) {
  uint32_t i = ctx->datalen;

  if (ctx->datalen < 56) {
    ctx->data[i++] = 0x80;
    memset(ctx->data + i, 0, 56 - i);
  } else {
    ctx->data[i++] = 0x80;
    memset(ctx->data + i, 0, 64 - i);
    SHA2_256_Transform(ctx->state, ctx->data, 1);
    memset(ctx->data, 0, 56);
  }

  // padding
  ctx->bitlen += ctx->datalen * 8;
  ((uint64_t *)ctx->data)[7] = htobe64(ctx->bitlen);

  SHA2_256_Transform(ctx->state, ctx->data, 1);

  ((uint32_t *)hash)[0] = htobe32(ctx->state[0]);
  ((uint32_t *)hash)[1] = htobe32(ctx->state[1]);
  ((uint32_t *)hash)[2] = htobe32(ctx->state[2]);
  ((uint32_t *)hash)[3] = htobe32(ctx->state[3]);
  ((uint32_t *)hash)[4] = htobe32(ctx->state[4]);
  ((uint32_t *)hash)[5] = htobe32(ctx->state[5]);
  ((uint32_t *)hash)[6] = htobe32(ctx->state[6]);
  ((uint32_t *)hash)[7] = htobe32(ctx->state[7]);
}

// caller responsible for making sure the buffer is big enough
uint64_t SHA2_256_Pad(uint8_t data[], size_t len) {
  uint64_t *bitlen_ptr;
  uint64_t nblk = len >> 6; // divide by 64, rounding down
  int remaining_bytes = len & 63;

  data[len] = 0x80;

  if (remaining_bytes < 56) {
    memset(data + len + 1, 0,  56 - (remaining_bytes + 1));
    nblk += 1;
  } else {
    memset(data + len + 1, 0, 120 - (remaining_bytes + 1));
    nblk += 2;
  }

  bitlen_ptr = (uint64_t *)(data + (nblk << 6) - 8);
  *bitlen_ptr = htobe64(len * 8);

  return nblk;
}

// caller is responsible for padding
void SHA2_256_Raw(uint8_t hash[], const uint8_t data[], uint64_t nblk) {
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  SHA2_256_Transform(state, data, nblk);

  ((uint32_t *)hash)[0] = htobe32(state[0]);
  ((uint32_t *)hash)[1] = htobe32(state[1]);
  ((uint32_t *)hash)[2] = htobe32(state[2]);
  ((uint32_t *)hash)[3] = htobe32(state[3]);
  ((uint32_t *)hash)[4] = htobe32(state[4]);
  ((uint32_t *)hash)[5] = htobe32(state[5]);
  ((uint32_t *)hash)[6] = htobe32(state[6]);
  ((uint32_t *)hash)[7] = htobe32(state[7]);
}

#include "sha256_xform.c"
#include "sha256_reg.c"
